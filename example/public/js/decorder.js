/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "../dist/audio-decoder.js":
/*!********************************!*\
  !*** ../dist/audio-decoder.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioDecoder\": () => (/* binding */ AudioDecoder)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass AudioDecoder {\n    constructor(worker) {\n        this._seq = 0;\n        this.onprogress = null;\n        this._completerMap = {};\n        this._worker = worker;\n        this._worker.onmessage = (ev) => this._handleMessage(ev);\n    }\n    _handleMessage(ev) {\n        var _a, _b;\n        if (((_a = ev.data) === null || _a === void 0 ? void 0 : _a.type) == 'progress') {\n            if (this.onprogress != null) {\n                this.onprogress(ev.data.data);\n            }\n            return;\n        }\n        const seq = (_b = ev.data) === null || _b === void 0 ? void 0 : _b.seq;\n        if (seq != null) {\n            const completer = this._completerMap[seq];\n            delete this._completerMap[seq];\n            completer(ev.data);\n        }\n    }\n    _request(req, transfer = []) {\n        var _a;\n        const seq = this._seq++;\n        const ts = Date.now();\n        (_a = this._worker) === null || _a === void 0 ? void 0 : _a.postMessage(Object.assign({ seq, ts }, req), transfer);\n        const ts2 = Date.now();\n        // console.log(`DecoderController req ${req.type}@${seq} ${ts2 - ts}ms`);\n        return new Promise((resolve, reject) => {\n            this._completerMap[seq] = (e) => {\n                const elapsed = Date.now() - ts2;\n                // console.log(`DecoderController res ${e.type}@${e.seq} ${elapsed}ms`);\n                if (e.error == null) {\n                    resolve(e.data);\n                }\n                else {\n                    reject(e.error);\n                }\n            };\n        });\n    }\n    init(sampleRate, numberOfChannels) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._request({ type: 'init', args: { sampleRate, numberOfChannels } });\n        });\n    }\n    start(outputPort, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._request({ type: 'start', outputPort, args }, [outputPort]);\n        });\n    }\n    abort() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._request({ type: 'abort' });\n        });\n    }\n    terminate() {\n        var _a;\n        (_a = this._worker) === null || _a === void 0 ? void 0 : _a.terminate();\n        this._worker = null;\n    }\n}\n\n\n//# sourceURL=webpack://webaudio-stream-player-example/../dist/audio-decoder.js?");

/***/ }),

/***/ "../dist/audio-player.js":
/*!*******************************!*\
  !*** ../dist/audio-player.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioPlayer\": () => (/* binding */ AudioPlayer)\n/* harmony export */ });\n/* harmony import */ var _audio_decoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audio-decoder.js */ \"../dist/audio-decoder.js\");\n/* harmony import */ var _audio_renderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audio-renderer.js */ \"../dist/audio-renderer.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass AudioPlayer {\n    constructor(args) {\n        var _a;\n        this._decoder = null;\n        this._renderer = null;\n        this._audioContext = null;\n        this._destination = null;\n        this._state = 'initial';\n        this._progress = {};\n        this.onstatechange = null;\n        this.onprogress = null;\n        this._rendererType = args.rendererType;\n        this._decoderUrl = args.decoderWorkerUrl;\n        this._rendererWorkletUrl = args.rendererWorkletUrl;\n        this._rendererWorkletName = args.rendererWorkletName;\n        this._recycleDecoder = (_a = args.recycleDecoder) !== null && _a !== void 0 ? _a : false;\n        this._numberOfChannels = args.numberOfChannels;\n    }\n    get numberOfChannels() { return this._numberOfChannels; }\n    changeRendererType(type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._rendererType != type) {\n                yield this.dispose();\n                this._rendererType = type;\n            }\n        });\n    }\n    get state() { return this._state; }\n    get progress() { return this._progress; }\n    connect(destination) {\n        if (!(destination.context instanceof AudioContext)) {\n            throw new Error('destination is not attached to an AudioContext.');\n        }\n        this._destination = destination;\n    }\n    disconnect() {\n        this._destination = null;\n        return this.dispose();\n    }\n    _attachContext(context) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._audioContext != context) {\n                if (this._audioContext != null) {\n                    yield this.dispose();\n                }\n                this._audioContext = context;\n                if (this._rendererType == 'worklet') {\n                    yield this._audioContext.audioWorklet.addModule(this._rendererWorkletUrl);\n                }\n            }\n        });\n    }\n    play(args) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            this._progress = {};\n            const mch = new MessageChannel();\n            yield this._attachContext(this._destination.context);\n            if (((_a = this._audioContext) === null || _a === void 0 ? void 0 : _a.state) == 'suspended') {\n                throw new Error('AudioContext is suspended. `await AudioContext.resume()` in advance within the call stack of a UI event handler.');\n            }\n            if (this._decoder == null) {\n                this._decoder = new _audio_decoder_js__WEBPACK_IMPORTED_MODULE_0__.AudioDecoder(new Worker(this._decoderUrl));\n                yield this._decoder.init(this._audioContext.sampleRate, this._numberOfChannels);\n            }\n            else {\n                yield this._decoder.abort();\n            }\n            yield this._decoder.start(mch.port2, args);\n            (_b = this._renderer) !== null && _b !== void 0 ? _b : (this._renderer = _audio_renderer_js__WEBPACK_IMPORTED_MODULE_1__.AudioRenderer.create(this._rendererType, this._audioContext, this._numberOfChannels, this._rendererWorkletName));\n            this._renderer.connect(this._destination);\n            this._renderer.onstatechange = (ev) => {\n                this._state = ev;\n                if (this.onstatechange != null) {\n                    this.onstatechange(ev);\n                }\n            };\n            this._decoder.onprogress = (data) => {\n                this._progress.decoder = data;\n                if (this.onprogress != null) {\n                    this.onprogress(this._progress);\n                }\n            };\n            this._renderer.onprogress = (data) => {\n                this._progress.renderer = data;\n                if (this.onprogress != null) {\n                    this.onprogress(this._progress);\n                }\n            };\n            yield this._renderer.play(mch.port1);\n        });\n    }\n    seekInFrame(frame, relative = false) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state != 'initial' && this._state != 'aborted') {\n                yield ((_a = this._renderer) === null || _a === void 0 ? void 0 : _a.seek(frame, relative));\n            }\n        });\n    }\n    seekInTime(time, relative = false) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state != 'initial' && this._state != 'aborted') {\n                const pos = Math.floor(this._audioContext.sampleRate / 1000 * time);\n                yield ((_a = this._renderer) === null || _a === void 0 ? void 0 : _a.seek(pos, relative));\n            }\n        });\n    }\n    togglePause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state == 'playing') {\n                return this.pause();\n            }\n            if (this._state == 'paused') {\n                return this.resume();\n            }\n        });\n    }\n    pause() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            yield ((_a = this._renderer) === null || _a === void 0 ? void 0 : _a.pause());\n        });\n    }\n    resume() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            yield ((_a = this._renderer) === null || _a === void 0 ? void 0 : _a.resume());\n        });\n    }\n    abort() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._decoder != null) {\n                yield this._decoder.abort();\n                this._decoder.onprogress = null;\n                if (!this._recycleDecoder) {\n                    this._decoder.terminate();\n                    this._decoder = null;\n                }\n            }\n            if (this._renderer != null) {\n                this._renderer.disconnect();\n                this._renderer.onprogress = null;\n                yield this._renderer.abort();\n            }\n        });\n    }\n    dispose() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._decoder != null) {\n                yield ((_a = this._decoder) === null || _a === void 0 ? void 0 : _a.abort());\n                this._decoder.onprogress = null;\n                this._decoder.terminate();\n                this._decoder = null;\n            }\n            if (this._renderer != null) {\n                this._renderer.disconnect();\n                this._renderer.onprogress = null;\n                this._renderer.onstatechange = null;\n                yield this._renderer.dispose();\n                this._renderer = null;\n            }\n            this._audioContext = null;\n        });\n    }\n}\n\n\n//# sourceURL=webpack://webaudio-stream-player-example/../dist/audio-player.js?");

/***/ }),

/***/ "../dist/audio-renderer.js":
/*!*********************************!*\
  !*** ../dist/audio-renderer.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioRenderer\": () => (/* binding */ AudioRenderer)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../dist/utils.js\");\n/* harmony import */ var _wave_buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wave-buffer.js */ \"../dist/wave-buffer.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass AudioRenderer {\n    constructor(delegate) {\n        this._delegate = delegate;\n    }\n    static create(type, context, numberOfChannels, workletName) {\n        if (type == 'worklet') {\n            if (workletName == null) {\n                throw new Error(`workletName must be specified.`);\n            }\n            return new AudioRenderer(new WorkletRenderer(context, numberOfChannels, workletName));\n        }\n        else if (type == 'script') {\n            return new AudioRenderer(new ScriptRenderer(context, numberOfChannels));\n        }\n        else {\n            throw new Error(`Unspported renderer type: ${type}`);\n        }\n    }\n    get state() { return this._delegate.state; }\n    ;\n    get onprogress() { return this._delegate.onprogress; }\n    set onprogress(f) { this._delegate.onprogress = f; }\n    get onstatechange() { return this._delegate.onstatechange; }\n    set onstatechange(f) { this._delegate.onstatechange = f; }\n    connect(destination) { return this._delegate.connect(destination); }\n    disconnect() { return this._delegate.disconnect(); }\n    play(input) { return this._delegate.play(input); }\n    seek(pos, relative = false) { return this._delegate.seek(pos, relative); }\n    pause() { return this._delegate.pause(); }\n    resume() { return this._delegate.resume(); }\n    abort() { return this._delegate.abort(); }\n    dispose() { return this._delegate.dispose(); }\n}\nclass WorkletRenderer {\n    constructor(audioContext, numberOfChannels, workletName) {\n        this._state = 'initial';\n        this._seq = 0;\n        this._completerMap = {};\n        this.onprogress = null;\n        this.onstatechange = null;\n        this._node = new AudioWorkletNode(audioContext, workletName, {\n            numberOfInputs: 0,\n            numberOfOutputs: 1,\n            outputChannelCount: [numberOfChannels],\n            // parameterData: null,\n            // processorOptions: null,\n        });\n        this._numberOfChannels = numberOfChannels;\n        this._node.port.onmessage = (ev) => this._handleMessage(ev);\n    }\n    get numberOfChannels() { return this._numberOfChannels; }\n    setState(newState) {\n        if (this._state != newState) {\n            this._state = newState;\n            if (this.onstatechange) {\n                this.onstatechange(this._state);\n            }\n        }\n    }\n    get state() { return this._state; }\n    _handleMessage(ev) {\n        var _a, _b, _c;\n        switch ((_a = ev.data) === null || _a === void 0 ? void 0 : _a.type) {\n            case 'progress':\n                if (this.onprogress != null) {\n                    this.onprogress(Object.assign({}, ev.data.stat));\n                }\n                break;\n            case 'state':\n                this.setState((_b = ev.data) === null || _b === void 0 ? void 0 : _b.state);\n                break;\n        }\n        const seq = (_c = ev.data) === null || _c === void 0 ? void 0 : _c.seq;\n        if (seq != null) {\n            const completer = this._completerMap[seq];\n            delete this._completerMap[seq];\n            completer(ev.data);\n        }\n    }\n    _request(req, transfer = []) {\n        const seq = this._seq++;\n        this._node.port.postMessage(Object.assign({ seq }, req), transfer);\n        // const start = Date.now();\n        return new Promise((resolve, reject) => {\n            this._completerMap[seq] = (e) => {\n                // const elapsed = Date.now() - start;\n                // console.log(`WorkletController[${e.seq}]:${e.type} ${elapsed}ms`);\n                if (e.error == null) {\n                    resolve(e.data);\n                }\n                else {\n                    reject(e.error);\n                }\n            };\n        });\n    }\n    connect(destination) { this._node.connect(destination); }\n    disconnect() { this._node.disconnect(); }\n    play(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state == 'playing' || this._state == 'paused') {\n                yield this._request({ type: 'abort' });\n            }\n            const res = yield this._request({ type: 'play', inputPort: input }, [input]);\n            this.setState('playing');\n        });\n    }\n    seek(pos, relative) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._request({ type: 'seek', seekPos: pos, relative });\n        });\n    }\n    pause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state == 'playing') {\n                const res = yield this._request({ type: 'pause' });\n                this.setState('paused');\n            }\n        });\n    }\n    resume() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state == 'paused') {\n                const res = yield this._request({ type: 'resume' });\n                this.setState('playing');\n            }\n        });\n    }\n    abort() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state != 'stopped' && this._state != 'aborted') {\n                const res = yield this._request({ type: 'abort' });\n                this.setState('aborted');\n            }\n        });\n    }\n    dispose() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._request({ type: 'dispose' });\n            this.setState('disposed');\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.isChrome) {\n                console.warn(`StreamerWorkletController.dispose: This operation may cause memory-leak on Chrome since Chrome will not release the AudioWorklet after the tied AudioContext is closed. See: https://bugs.chromium.org/p/chromium/issues/detail?id=1298955`);\n            }\n        });\n    }\n    ;\n}\nclass ScriptRenderer {\n    constructor(audioContext, numberOfChannels) {\n        this._inputPort = null;\n        this._state = 'initial';\n        this.onprogress = null;\n        this.onstatechange = null;\n        this._node = audioContext.createScriptProcessor(1024, 0, numberOfChannels);\n        this._node.onaudioprocess = (ev) => this._onAudioProcess(ev);\n        this._buffer = new _wave_buffer_js__WEBPACK_IMPORTED_MODULE_1__.WaveBuffer(audioContext.sampleRate, numberOfChannels);\n        this._numberOfChannels = numberOfChannels;\n    }\n    get numberOfChannels() { return this._numberOfChannels; }\n    get state() { return this._state; }\n    setState(newState) {\n        if (this._state != newState) {\n            this._state = newState;\n            if (this.onstatechange != null) {\n                this.onstatechange(this._state);\n            }\n        }\n    }\n    connect(destination) { this._node.connect(destination); }\n    disconnect() { this._node.disconnect(); }\n    play(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._inputPort != null) {\n                this._inputPort.onmessage = null;\n                this._inputPort.close();\n            }\n            this._inputPort = input;\n            this._inputPort.onmessage = (ev) => this._buffer.write(ev.data);\n            this._buffer.clear();\n            this.setState('playing');\n        });\n    }\n    seek(pos, relative) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._buffer.seekTo(pos, relative);\n        });\n    }\n    pause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state == 'playing') {\n                this.setState('paused');\n            }\n        });\n    }\n    resume() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state == 'paused') {\n                this.setState('playing');\n            }\n        });\n    }\n    abort() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._state == 'playing' || this._state == 'paused') {\n                this._buffer.clear();\n                this.setState('aborted');\n            }\n        });\n    }\n    _onAudioProcess(ev) {\n        if (this._state == 'playing') {\n            const res = this._buffer.onAudioProcess(ev);\n            if (this.onprogress != null) {\n                const stat = this._buffer.stat;\n                this.onprogress(this._buffer.stat);\n            }\n            if (!res) {\n                this._buffer.clear();\n                this.setState('stopped');\n            }\n        }\n    }\n    dispose() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._buffer.clear();\n            if (this._inputPort != null) {\n                this._inputPort.onmessage = null;\n                this._inputPort.close();\n                this._inputPort = null;\n            }\n            this._node.onaudioprocess = null;\n            this.setState('disposed');\n        });\n    }\n}\n\n\n//# sourceURL=webpack://webaudio-stream-player-example/../dist/audio-renderer.js?");

/***/ }),

/***/ "../dist/index.js":
/*!************************!*\
  !*** ../dist/index.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioDecoder\": () => (/* reexport safe */ _audio_decoder_js__WEBPACK_IMPORTED_MODULE_1__.AudioDecoder),\n/* harmony export */   \"AudioDecoderWorker\": () => (/* reexport safe */ _workers_audio_decoder_worker_js__WEBPACK_IMPORTED_MODULE_3__.AudioDecoderWorker),\n/* harmony export */   \"AudioPlayer\": () => (/* reexport safe */ _audio_player_js__WEBPACK_IMPORTED_MODULE_0__.AudioPlayer),\n/* harmony export */   \"AudioRenderer\": () => (/* reexport safe */ _audio_renderer_js__WEBPACK_IMPORTED_MODULE_2__.AudioRenderer)\n/* harmony export */ });\n/* harmony import */ var _audio_player_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./audio-player.js */ \"../dist/audio-player.js\");\n/* harmony import */ var _audio_decoder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audio-decoder.js */ \"../dist/audio-decoder.js\");\n/* harmony import */ var _audio_renderer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./audio-renderer.js */ \"../dist/audio-renderer.js\");\n/* harmony import */ var _workers_audio_decoder_worker_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./workers/audio-decoder-worker.js */ \"../dist/workers/audio-decoder-worker.js\");\n\n\n\n\n// DO NOT EXPORT from './workers/audio-renderer-worklet-processor.js';\n// If export, webpack bundles this into the main GlobalScope, not AudioWorkletGlobalScope.\n\n\n//# sourceURL=webpack://webaudio-stream-player-example/../dist/index.js?");

/***/ }),

/***/ "../dist/utils.js":
/*!************************!*\
  !*** ../dist/utils.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isChrome\": () => (/* binding */ isChrome),\n/* harmony export */   \"isSafari\": () => (/* binding */ isSafari)\n/* harmony export */ });\nconst isSafari = (() => {\n    const maybeSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    if (maybeSafari) {\n        if (/google/i.test(navigator.vendor)) {\n            // A fake Safari that may be a mobile simulator on Chrome.\n            return false;\n        }\n        return true;\n    }\n    return false;\n})();\nconst isChrome = (() => {\n    var _a;\n    const uad = navigator.userAgentData;\n    if (uad && ((_a = uad === null || uad === void 0 ? void 0 : uad.brands[0]) === null || _a === void 0 ? void 0 : _a.brand) == 'Google Chrome') {\n        return true;\n    }\n    return false;\n})();\n\n\n//# sourceURL=webpack://webaudio-stream-player-example/../dist/utils.js?");

/***/ }),

/***/ "../dist/wave-buffer.js":
/*!******************************!*\
  !*** ../dist/wave-buffer.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WaveBuffer\": () => (/* binding */ WaveBuffer)\n/* harmony export */ });\nfunction createSameTypeBuffer(prot, length) {\n    if (prot instanceof Float32Array) {\n        return new Float32Array(length);\n    }\n    else if (prot instanceof Int32Array) {\n        return new Int32Array(length);\n    }\n    else if (prot instanceof Int16Array) {\n        return new Int16Array(length);\n    }\n    else if (prot instanceof Int8Array) {\n        return new Int8Array(length);\n    }\n    else if (prot instanceof Uint8Array) {\n        return new Uint8Array(length);\n    }\n    else {\n        throw new Error(`Unsupported array type ${typeof prot}`);\n    }\n}\nclass MonoWaveBuffer {\n    constructor(initialLength) {\n        this._wave = null;\n        this.rp = 0;\n        this.wp = 0;\n        this._initialLength = initialLength;\n    }\n    get byteLength() {\n        if (this._wave != null) {\n            return this.wp * this._wave.BYTES_PER_ELEMENT;\n        }\n        return 0;\n    }\n    seekTo(frame, relative) {\n        if (relative) {\n            this.rp += frame;\n        }\n        else {\n            this.rp = frame;\n        }\n        this.rp = Math.min(Math.max(0, this.rp), this.wp);\n    }\n    clear() {\n        this._wave = null;\n        this.wp = 0;\n        this.rp = 0;\n    }\n    write(data) {\n        if (this._wave == null) {\n            this._wave = createSameTypeBuffer(data, this._initialLength);\n        }\n        if (typeof data != typeof this._wave) {\n            throw new Error(`The type of wave sample has changed during playing from ${typeof this._wave} to ${typeof data}.`);\n        }\n        if (this.wp + data.length > this._wave.length) {\n            const newWave = createSameTypeBuffer(this._wave, this._wave.length * 2);\n            newWave.set(this._wave);\n            this._wave = newWave;\n        }\n        this._wave.set(data, this.wp);\n        this.wp += data.length;\n    }\n    process(output) {\n        if (this._wave instanceof Float32Array) {\n            for (let i = 0; i < output.length; i++) {\n                if (this.rp < this.wp) {\n                    output[i] = this._wave[this.rp++];\n                }\n            }\n        }\n        else if (this._wave instanceof Int32Array) {\n            for (let i = 0; i < output.length; i++) {\n                if (this.rp < this.wp) {\n                    output[i] = this._wave[this.rp++] / (1 << 31);\n                }\n            }\n        }\n        else if (this._wave instanceof Int16Array) {\n            for (let i = 0; i < output.length; i++) {\n                if (this.rp < this.wp) {\n                    output[i] = this._wave[this.rp++] / (1 << 15);\n                }\n            }\n        }\n        else if (this._wave instanceof Int8Array) {\n            for (let i = 0; i < output.length; i++) {\n                if (this.rp < this.wp) {\n                    output[i] = this._wave[this.rp++] / (1 << 7);\n                }\n            }\n        }\n        else if (this._wave instanceof Uint8Array) {\n            for (let i = 0; i < output.length; i++) {\n                if (this.rp < this.wp) {\n                    output[i] = (this._wave[this.rp++] - 128) / (1 << 7);\n                }\n            }\n        }\n        else {\n            // do nothing\n        }\n    }\n}\nclass WaveBuffer {\n    constructor(sampleRate, numberOfChannels) {\n        this.isFulFilled = false;\n        this._sampleRate = sampleRate;\n        this._waves = Array();\n        for (let i = 0; i < numberOfChannels; i++) {\n            this._waves.push(new MonoWaveBuffer(sampleRate * 60));\n        }\n    }\n    seekTo(frame, relative) {\n        for (const wave of this._waves) {\n            wave.seekTo(frame, relative);\n        }\n    }\n    clear() {\n        for (const wave of this._waves) {\n            wave.clear();\n        }\n    }\n    get stat() {\n        const currentFrame = this._waves[0].rp;\n        const bufferedFrames = this._waves[0].wp;\n        return {\n            currentFrame,\n            currentTime: Math.floor(currentFrame / this._sampleRate * 1000),\n            bufferedFrames,\n            bufferedTime: Math.floor(bufferedFrames / this._sampleRate * 1000),\n            isFulFilled: this.isFulFilled,\n        };\n    }\n    write(inputs) {\n        if (inputs == null || inputs.length == 0 || inputs[0] == null) {\n            this.isFulFilled = true;\n            console.log(`buffered: ${(this._waves[0].byteLength / 1024 / 1024).toFixed(2)}MB`);\n        }\n        else {\n            const k = Math.min(inputs.length, this._waves.length);\n            for (let i = 0; i < k; i++) {\n                this._waves[i].write(inputs[i]);\n            }\n        }\n    }\n    _processImpl(channels) {\n        const k = Math.min(channels.length, this._waves.length);\n        for (let i = 0; i < k; i++) {\n            this._waves[i].process(channels[i]);\n        }\n        if (this.isFulFilled && this._waves[0].rp == this._waves[0].wp) {\n            return false;\n        }\n        return true;\n    }\n    onAudioProcess(ev) {\n        const channels = [];\n        for (let i = 0; i < ev.outputBuffer.numberOfChannels; i++) {\n            channels.push(ev.outputBuffer.getChannelData(i));\n        }\n        return this._processImpl(channels);\n    }\n    onAudioWorkletProcess(inputs, outputs) {\n        const channels = outputs[0];\n        return this._processImpl(channels);\n    }\n}\n\n\n//# sourceURL=webpack://webaudio-stream-player-example/../dist/wave-buffer.js?");

/***/ }),

/***/ "../dist/workers/audio-decoder-worker.js":
/*!***********************************************!*\
  !*** ../dist/workers/audio-decoder-worker.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AudioDecoderWorker\": () => (/* binding */ AudioDecoderWorker)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass InternalProcessor {\n    constructor(id, process) {\n        this.aborted = false;\n        this._completer = null;\n        this.id = id;\n        this._process = process;\n    }\n    abort() {\n        this.aborted = true;\n        return this._completer;\n    }\n    run() {\n        this._completer = new Promise((resolve) => {\n            const res = this._process(this);\n            resolve(res);\n        });\n        return this._completer;\n    }\n}\nclass AudioDecoderWorker {\n    constructor(worker) {\n        this._outputPort = null;\n        this._processorId = 0;\n        this._processor = null;\n        this._sampleRate = 44100;\n        this._numberOfChannels = 2;\n        this._worker = worker;\n        this._worker.onmessage = (e) => __awaiter(this, void 0, void 0, function* () {\n            let res;\n            const req = e.data;\n            try {\n                const data = yield this._onRequest(req);\n                res = { seq: req.seq, type: req.type, data: data };\n            }\n            catch (e) {\n                res = { seq: req.seq, type: req.type, error: e };\n            }\n            this._worker.postMessage(res);\n        });\n    }\n    _detachPort() {\n        var _a;\n        if (this._outputPort != null) {\n            this._outputPort.onmessage = null;\n            (_a = this._outputPort) === null || _a === void 0 ? void 0 : _a.close();\n            this._outputPort = null;\n        }\n    }\n    get sampleRate() { return this._sampleRate; }\n    get numberOfChannels() { return this._numberOfChannels; }\n    _onRequest(req) {\n        return __awaiter(this, void 0, void 0, function* () {\n            switch (req.type) {\n                case 'init':\n                    this._sampleRate = req.args.sampleRate;\n                    this._numberOfChannels = req.args.numberOfChannels;\n                    yield this.init(req.args);\n                    break;\n                case 'start':\n                    if (this._processor != null) {\n                        throw new Error(`Already started.`);\n                    }\n                    this._outputPort = req.outputPort;\n                    yield this.start(req.args);\n                    this._run();\n                    return;\n                case 'abort':\n                    yield this._abort();\n                    yield this.abort();\n                    this._detachPort();\n                    return;\n                case 'dispose':\n                    yield this._abort();\n                    yield this.dispose();\n                    this._detachPort();\n                    return;\n                default:\n                    throw new Error(`Uknown request type: ${req.type}`);\n            }\n        });\n    }\n    _dispatchProgress(elapsed, decodeFrames, isDecoding) {\n        const decodeSpeed = elapsed != 0 ? (decodeFrames / this.sampleRate * 1000) / elapsed : 0;\n        this._worker.postMessage({\n            type: 'progress', data: {\n                decodeFrames,\n                decodeSpeed,\n                isDecoding,\n            }\n        });\n    }\n    _run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const start = Date.now();\n            let decodeFrames = 0;\n            this._processor = new InternalProcessor(this._processorId++, (parent) => __awaiter(this, void 0, void 0, function* () {\n                var _a, _b;\n                while (!parent.aborted) {\n                    const channels = yield this.process();\n                    if (channels != null) {\n                        decodeFrames += channels[0].length;\n                        const transfer = channels.map((e) => e.buffer);\n                        (_a = this._outputPort) === null || _a === void 0 ? void 0 : _a.postMessage(channels, transfer);\n                    }\n                    else {\n                        (_b = this._outputPort) === null || _b === void 0 ? void 0 : _b.postMessage(null);\n                        break;\n                    }\n                    this._dispatchProgress(Date.now() - start, decodeFrames, true);\n                    yield new Promise((resolve) => setTimeout(resolve, 0));\n                }\n            }));\n            yield this._processor.run();\n            this._dispatchProgress(Date.now() - start, decodeFrames, false);\n            this._processor = null;\n        });\n    }\n    _abort() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._processor != null) {\n                const id = this._processor.id;\n                yield this._processor.abort();\n                this._processor = null;\n            }\n        });\n    }\n}\n\n\n//# sourceURL=webpack://webaudio-stream-player-example/../dist/workers/audio-decoder-worker.js?");

/***/ }),

/***/ "./src/my-decoder-worker.js":
/*!**********************************!*\
  !*** ./src/my-decoder-worker.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var audio_stream_player__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! audio-stream-player */ \"../dist/index.js\");\n\n\nclass MyDecoderWorker extends audio_stream_player__WEBPACK_IMPORTED_MODULE_0__.AudioDecoderWorker {\n  constructor(worker) {\n    super(worker);\n  }\n\n  async init(args) { /* initialize if needed */ }\n\n  async start(args) {\n    this.leftFreq = args.leftFreq || 440.0;\n    this.rightFreq = args.rightFreq || 441.0;\n    this.phase = 0;\n    this.aborted = false;\n  }\n\n  async process() {\n    const channels = [];\n    for (let c = 0; c < this.numberOfChannels; c++) {\n      channels.push(new Float32Array(this.sampleRate));\n    }\n    for (let i = 0; i < this.sampleRate; i++) {\n      for (let c = 0; c < channels.length; c++) {\n        const freq = c == 0 ? this.leftFreq : this.rightFreq;\n        channels[c][i] = Math.sin(2 * Math.PI * freq * this.phase / this.sampleRate);\n      }\n      this.phase++;\n    }\n    return channels;\n  }\n\n  async abort() { /* something to do when aborted */ }\n  async dispose() { /* dispose resources here */ }\n}\n\nconst decoder = new MyDecoderWorker(self);\n\n//# sourceURL=webpack://webaudio-stream-player-example/./src/my-decoder-worker.js?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/my-decoder-worker.js");
/******/ 
